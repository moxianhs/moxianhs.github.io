


[{"content":"","date":"2025年10月25日","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2025年10月25日","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025年10月25日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025年10月25日","externalUrl":null,"permalink":"/","section":"默","summary":"","title":"默","type":"page"},{"content":"","date":"2025年10月25日","externalUrl":null,"permalink":"/tags/%E7%94%9F%E6%B4%BB%E6%96%B9%E5%BC%8F/","section":"Tags","summary":"","title":"生活方式","type":"tags"},{"content":"","date":"2025年10月25日","externalUrl":null,"permalink":"/categories/%E9%9A%8F%E7%AC%94/","section":"Categories","summary":"","title":"随笔","type":"categories"},{"content":" 购入 # 这部 iPhone 13 陪伴我已经有了 4 年光景了。\n我仍然记得，那是 2021 年的 12 月 25 日的黄昏，所谓圣诞节，刚刚从上海二工大的考场出来。\n考研的结果是疲惫的，何况是在职。\n在回家的地铁上，手机号欠费了。而那时候我的手上，是一个刚买了还不足一年的 iPhone 12 mini ，我很喜爱的小屏手机。\n单卡。\n就这样，彼时还没有开始修心的我，在与网络世界断联的情况下，于嘈杂的地铁上，度过了难熬的几十分钟。\n回到家，充上话费，没有多停留一刻，就立刻出门，去了五角场的苹果，把 12 mini 换成了新出的 13 。全程在怨念的支配下，十分的丝滑。我还记得店员问我：「这回不用 mini 了？」，我回答：「单卡实在不行了，受不了」。\n破碎 # 在 2023 年，我正式考研的那年，考前一个月。\n我已经独居复习有些时日了。 12 月 3 日，我下楼跑步，可能是没有太经常活动的原因，在一个下坡，一个没留神，崴了脚。手机也就顺势飞了出去。\n购入之后，一直也都是裸奔着使用，我没太在意边框上的大大小小的磕碰。\n这一次，不仅我的左脚成了猪蹄。手机的屏幕也终于碎成了难以忽视的形状。\n但彼时的我，已经是脱产考研的状态。无法再支撑我买一部昂贵的 iPhone 。\n管家里要，不是不行，但我也没脸要贵的。\n所幸，那年足够刻苦，考上了。\n碎了屏的 iPhone 被我封存了。最终买了一部一加，是喜欢的联名款，不贵，各种新鲜的性能参数。\n重新启用 # 一加用作主力机，直到今年初。\n年初报名了去东京大学的交流活动。基于去年去日本第二次旅行的经验，还是 iPhone 刷交通卡方便。而且一加的背部玻璃在我一次不小心的操作下，裂了个缝，抱着不见心不烦的心态，重新将 iPhone 用作主力。\n想象中的不适应似乎没来。\n我开始下意识观察，观察这么一部放到网上该被喷成「垃圾」的手机，我是怎么这么用着的。\n我能感知到，在几年没怎么充电的情况下，电池已经烂得没边。但一点，在几年前我就已经有了十分自然的解决方案。\n「MagSafe」就是答案，我在两点一线的生活里，可以直接在两端都放一个磁吸充电台，到地方，手机一吸，随时都在充电。算下来只有通勤的时候，手机处于掉电的状态。几乎随时都在充电，也就不用考虑什么「快充」了。\n出门的时候，带上一个磁吸移动电源，也就还行，不会有什么焦虑。毕竟我不在手机上打游戏，没有什么电牛。\n然后就是，「刷新率」。\n因为我有一部一加，有快充，有高刷，我能清晰做对比，所以我也能感知到高刷的效果。\n但在把两部手机放在一起，好好地感受了一番高刷之后。平日的使用里，我依旧是该怎么用就怎么用。\n想了想，大概，手机屏幕上，真正有意义的，应该是里面的信息。换句话就是，平日里的我，根本注意不到刷新率。 我是在使用手机，而非评测参数。\nMac # 现在在实验室里，我应该是唯一一个将 Mac 用作主力机器的。\n我为什么使用 Mac 呢？\n这就要大概追溯到大一 C++ 实践课上的惊鸿一瞥了。\n我瞥到老师在用一个没见过的软件编辑代码，那个软件的 logo 长得挺别致。\n那个软件，叫 Emacs 。\n什么叫一见误终身，这就是。\n自那以后，所有软件能调快捷键我就都得调成 Emacs 类的快捷键。在用浏览器的时候，我总会因为 C-n 开启新的窗口， C-p 开启打印界面。\n因为 Emacs ，我甚至买过 HHKB 的键盘。\nLinux 也一度成为了我的主力系统。\n教我数据库的老师，曾经在第一节课上说，「你们谁的电脑是 Linux 系统的，期末我直接给他加 5 分。」，我应该是唯一一个直接举手的。\n但 Linux 坏就坏在，图形界面太容易被搞坏了。虽然这些问题肯定能被解决，毕竟所有代码都在那儿，花时间一定能解决。\n折腾还是太磨人了。\n如果，偶尔一个问题上头，猛猛折腾个几天，那是十分舒爽的心流体验。\n但如果成为日常，日复一日，还不知道会有多少未知的在等待，那就很恐怖了。\n所以，在大三的时候，我买了第一台 MacBook Pro 。\nOS X 全系统直接支持 Emacs 系的快捷键，比很多 Linux 系统都全面。浏览器不会再跳新页面了。\n手，终于可以在键盘中间放着就能完成绝大部分操作，不用再去够在边缘的方向键了。\n好，说回 Mac ，Emacs 我会择日写在新的文章里。\n在 Emacs 键绑定的「绑架」下，我越发离不开 Mac 。\n毕竟，我的绝大部分工作就是软件开发，用什么系统反而真的不重要，Mac 对 Linux 的绝赞兼容性（对比 Windows ）来说，甚至一定程度上是一种助力。\n至于其与 iPhone 的各种互联，只能算是一些可有可无的彩蛋，毕竟我不只有苹果系的设备。需要娱乐的时候，我还是得用 Windows 。\n在手里的 Windows 笔记本续航越来越拉胯，mbp 也早就被卖掉的情况下，我突然起了个念头：\n「买个带苹果灯标的 MacBook Air 吧」\n于是，有了一台在转转上花 800 买的 2017 款的 MacBook Air ，是我曾经一度非常心水的样子，可惜已经停产一个时代了。\n续航还不错，传感器有些问题，所以盒盖待机续航不如预期，该关机得关机。\n也是因为这台 MacBook ，我有了新的思考。\n二手 # 作为一个学生，捉襟见肘是常态，虽然我能拿的津贴，应该在全国也没多少比我高的。\nMacBook Air 的故事提醒我，为什么不能买二手的？\n前面 iPhone 的事情，也能证明，我其实在乎的并非那些先进的参数。\n一查，Apple Watch Ultra 一代，一千多两千多就能拿下二手的，而且成色似乎还不错。\niPhone 13 用到今天，确实有些吃力了，尤其是有微信的这个混蛋，用起来更是显得日薄西山。\n今年的 17 看起来不错。或许可以考虑，明年买个 17 Pro ，因为我发现我需要适当升级一下我用来拍 Vlog 的设备了。单买一个 Pocket 3 或者运动相机确实性价比太低了，不如换手机的时候换个视频性能强的。\n「新品导向」或者「新品惯性」 # 我买过小米 2S ，买过索尼的 Xperia ，买过 iPhone 6S 和 iPhone SE ，买过华为的 Mate 30 等等等等。无一例外，都是在这些机器都还是新品的时候买的。\n越到后面，其实新品和上一代的区别越来越小了。\n年年「追新」的意义越来越模糊了。\n何况，我压根不在乎。\n以前的我，大概是一种「新品导向」或者叫「新品惯性」的状态。\n如今清醒了，便没有必要为新品高昂的售价付出额外的代价了。\n我果然还是变了。\n所以，一个 iPhone 和一台 MacBook Air 就这么治好了了我的新品依赖。\n","date":"2025年10月25日","externalUrl":null,"permalink":"/posts/no-more-new/","section":"Posts","summary":"","title":"战损的 iPhone 13 和 2017 款二手 MacBook Air 治好了我的新品导向","type":"posts"},{"content":"","date":"2025年10月11日","externalUrl":null,"permalink":"/tags/emacs/","section":"Tags","summary":"","title":"Emacs","type":"tags"},{"content":"","date":"2025年10月11日","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"","date":"2025年10月11日","externalUrl":null,"permalink":"/tags/org/","section":"Tags","summary":"","title":"Org","type":"tags"},{"content":"","date":"2025年10月11日","externalUrl":null,"permalink":"/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/","section":"Categories","summary":"","title":"技术教程","type":"categories"},{"content":" 配置 # 我是使用 Doom Emacs 的配置，所以在添加 ox-hugo 支持方面比较简单。\n(doom! ;; 其他配置 :lang (org +pretty +hugo) ) 在你的博客目录下，开一个用来放 org 的目录，比如根目录下：\n~/W/Blog/mox-blog [main] λ tree -L 1 . ├── archetypes ├── assets ├── config ├── content ├── data ├── hugo.toml ├── i18n ├── layouts ├── org ├── public ├── resources ├── static └── themes 13 directories, 1 file 在 org 目录下就可以用 org-mode 写博客了。\n确定好目录位置后，需要在博客的头部元数据里指定 hugo 工程的目录，也就是当前博客的根目录：\n#+title: 如何在 Hugo 里写 Org #+author: Mox W #+date: \u0026lt;2025-10-11 六\u0026gt; #+hugo_base_dir: ../ #+filetags: Emacs Org Hugo @技术教程 顺便说明一下 Tag 和 Category 怎么配置：\n#+filetags: tag1 tag2 @cat1 @cat2 可以看到，标签或分类之间是用空格分割的。如果希望标签或分类本身就包含空格呢？\nox-hugo 使用如下规则：\nabc_def -\u0026gt; abc-def abc__def -\u0026gt; abc def abc___def -\u0026gt; abc_def 生成 Markdown # 直接使用 org 写就的文章，需要转换成 Markdown 才能被 Hugo 识别。\n在 Emacs 里，我们直接祭出 M-x 大法： M-x org-export-dispatch\n然后在弹出的菜单里敲击 H h 即可。\n这里注意一定是生成 Hugo Capatible Markdown ，选择 File to Md file 。\n其他选项里可能有 subtree to md file ，这相当于只将某一个标题（子树）导出。\n只要配置好 hugo_base_dir ，导出的 md 文件应该就会正常地落到 content/posts/ 里。\n试一试吧。\n","date":"2025年10月11日","externalUrl":null,"permalink":"/posts/write-org-in-hugo/","section":"Posts","summary":"","title":"如何在 Hugo 里写 Org","type":"posts"},{"content":"","date":"2025年10月9日","externalUrl":null,"permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux","type":"tags"},{"content":"","date":"2025年10月9日","externalUrl":null,"permalink":"/tags/openeuler/","section":"Tags","summary":"","title":"OpenEuler","type":"tags"},{"content":"","date":"2025年10月9日","externalUrl":null,"permalink":"/tags/%E5%AE%89%E8%A3%85/","section":"Tags","summary":"","title":"安装","type":"tags"},{"content":"","date":"2025年10月9日","externalUrl":null,"permalink":"/tags/%E6%8D%A2%E6%BA%90/","section":"Tags","summary":"","title":"换源","type":"tags"},{"content":" 安装 # 如正常安装 openEuler 一样安装。\n换源 # 先找到设备号\nlsblk # 在结果里找到 TYPE 为 rom 的设备，看看大小对不对 假设是 /dev/sr0 （大概率是这个）\n挂载：\nmkdir -p /mnt/everything mount /dev/sr0 /mnt/everything 换源：\n# 备份一下 mv /etc/yum.repo.d/openEuler.repo /etc/yum.repo.d/openEuler.repo.backup vi /etc/yum.repo.d/openEuler.repo 将文件内容改为以下：\n[openEuler] name=openEuler baseurl=file:///mnt/everything enable=1 gpgcheck=0 以上文件名需要随机应变，根据现场环境更改。\n测试一下：\nyum clean all yum makecache yum install vim 不出意外应该就能装了。\n","date":"2025年10月9日","externalUrl":null,"permalink":"/posts/euler-everything/","section":"Posts","summary":"","title":"离线环境下使用 everthing 版本 ISO 安装 openEuler 系统并换源","type":"posts"},{"content":"","date":"2025年10月9日","externalUrl":null,"permalink":"/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/","section":"Categories","summary":"","title":"系统运维","type":"categories"},{"content":" 关于我 一个始终在徒劳的人。\n希望讲故事给世界听。\n在一个玖捌伍给电脑的内存打补丁。\n博客的设计上，借鉴了 昼梦日和 ，非常好审美使我大脑旋转。\n评论系统参考了这个博客 和 昼梦日和。\n施工 TODO 重新设计首页 添加统计信息 添加评论系统 添加标签 删除部分无用草稿 修改字体 调整配色 部分配图重新设计 添加 SEO 相关支持 ","date":"2025年10月8日","externalUrl":null,"permalink":"/about/","section":"默","summary":"","title":"About","type":"page"},{"content":"","date":"2025年10月8日","externalUrl":null,"permalink":"/tags/ai/","section":"Tags","summary":"","title":"AI","type":"tags"},{"content":"","date":"2025年10月8日","externalUrl":null,"permalink":"/tags/cherry-studio/","section":"Tags","summary":"","title":"Cherry Studio","type":"tags"},{"content":"","date":"2025年10月8日","externalUrl":null,"permalink":"/tags/siliconflow/","section":"Tags","summary":"","title":"SiliconFlow","type":"tags"},{"content":" 概览 # 通过使用 Cherry Studio ，你可以调用各种各样的大语言模型（Large Language Model）来完成你需要 AI 回答你的任何问题。\n这些大模型都是各个厂商通过应用程序接口（Application Programming Interface, API）的形式提供。\n你可以选择使用 OpenAI 提供的 ChatGPT 或者 Anthropic 提供的 Claude 等等，但服务受限，喜欢封号，价格昂贵是不得不考虑的问题。\n你也可以选择使用开源模型服务平台，这里会用云平台提供大量的已经部署好的开源模型，可以直接调用，且价格低廉。\n你经历过使用官方的 DeepSeek ，不断重复服务忙服务暂时不可用的事情吗？你有经历过使用腾讯元宝或者其他第三方部署的 DeepSeek ，发现参数量不透明性能不好不能及时更新版本吗？\n使用硅基流动（SiliconFlow）这种平台就能解决这些问题。\n硅基流动 # 首先在硅基流动的 官网 里，像其他网站一样注册一个账号。\n通过我的邀请链接注册，你和我都会获得 14 元的赠送余额，所以，拜托了：注册链接\n登录后，就会进入到模型广场的界面：\n在这里就可以知道当前有哪些模型可以供你调用。\n需要注意的是，硅基流动的费用体系，分为「赠送余额」和「充值余额」：\n部分模型例如 Pro 开头的模型，都是只能使用充值余额的，但不带 Pro 前缀的模型，基本上都是可以使用赠送余额的。\n「💰」图标表示的就是支持使用充值余额。 「🎁」图表表示的就是支持使用赠送余额。 赠送余额是注册时赠送的，完成校园认证也会给一些。\n点击一个模型，就会弹出其详情页面，会展示其类型、参数量、价格等一系列信息。点击模型名后面的复制图标，可快捷复制模型名，以供调用时使用：\n点击在线体验，可以直接跳转到试用界面，直接尝试对应的模型，此处的使用方式就和其他服务（ChatGPT, DeepSeek） 没什么太大的区别了：\n挑选好心仪的模型（不知道怎么选，就选最新的）后，就可以进入到下一节了。\nCherry Studio # Cherry Studio 直译就是樱桃工作室，可以在本地调用各种服务商提供的大模型服务，且所有数据都存在本地，故软件本身不会引入任何隐私风险。\n打开 Cherry Studio 的 官网 ，点击下载客户端即可：\n对于一般 Windows 系统，下载 Windows 标准版即可。\n下载安装完成之后，打开 Cherry Studio ，就能得到类似以下界面：\n点击左下角的齿轮设置图标，进入设置界面，需要配置硅基流动的 API 密钥才能愉快使用之前在硅基流动那边选好的模型。\n回到硅基流动这边，点击侧边栏的钥匙按钮，进入密钥管理的界面：\n点击「新建 API 密钥」，输入密钥描述即可点击「新建密钥」：\n复制新的密钥：\n回到 Cherry Studio 这里，在设置里输出硅基流动的 API Key：\n点击右侧的检测按钮，在弹出页面里，随意选择一个内置的模型，点击确定，弹出「连接成功」或者密钥右侧的检测按钮变成绿色的对钩，就可以了。\n还记得之间可以复制模型名吗？现在到时候了。\n复制好需要的模型名，在 Cherry Studio 的硅基流动设置页面里，滚动到最下面，有个添加模型，把你复制的模型名贴进去就好啦。\n添加好，就可以回到最开始 Cherry Studio 的页面，开始一轮对话啦。\n在对话页面，点击话题，就可以看到过往的聊天记录和新增话题的按钮。\n其中，顶部的模型名点击之后可以切换模型，如果没有你想要的则去设置里添加：\n现在，一个可以使用的 Cherry Studio 就展现在你面前，在输入框里提一个问题，然后按下回车吧。\n课后习题 # Cherry Studio 还有很多很多按钮我没有介绍是什么，但此时已经有一个可以使用的提问系统了，所以你应该怎么做，就不用我多说了吧？\n不知道？去问 AI 啊。\n","date":"2025年10月8日","externalUrl":null,"permalink":"/posts/cherry-studio-and-siliconflow/","section":"Posts","summary":"","title":"给完全陌生者的 Cherry Studio 和 SiliconFlow 入门指南","type":"posts"},{"content":"","date":"2025年10月8日","externalUrl":null,"permalink":"/tags/%E5%B7%A5%E5%85%B7/","section":"Tags","summary":"","title":"工具","type":"tags"},{"content":"","date":"2025年10月8日","externalUrl":null,"permalink":"/tags/%E6%95%99%E7%A8%8B/","section":"Tags","summary":"","title":"教程","type":"tags"},{"content":"","date":"2025年1月2日","externalUrl":null,"permalink":"/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/","section":"Tags","summary":"","title":"静态博客","type":"tags"},{"content":"如下图所示，是本文希望达到的效果。\n![Logo](/img/miHoYo-Logo.png) 将图片文件放到static下面，编译后会自动引入。\nls static/img/ miHoYo-Logo.png ","date":"2025年1月2日","externalUrl":null,"permalink":"/posts/imgs-beside-article/","section":"Posts","summary":"","title":"静态博客文章里的图片","type":"posts"},{"content":"","date":"2025年1月2日","externalUrl":null,"permalink":"/tags/%E9%85%8D%E7%BD%AE/","section":"Tags","summary":"","title":"配置","type":"tags"},{"content":"","date":"2025年1月2日","externalUrl":null,"permalink":"/tags/%E5%9B%BE%E7%89%87/","section":"Tags","summary":"","title":"图片","type":"tags"},{"content":"","date":"2024年12月23日","externalUrl":null,"permalink":"/tags/gcov/","section":"Tags","summary":"","title":"Gcov","type":"tags"},{"content":"","date":"2024年12月23日","externalUrl":null,"permalink":"/tags/%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95/","section":"Tags","summary":"","title":"代码测试","type":"tags"},{"content":"","date":"2024年12月23日","externalUrl":null,"permalink":"/tags/%E8%A6%86%E7%9B%96%E7%8E%87/","section":"Tags","summary":"","title":"覆盖率","type":"tags"},{"content":" Gcov + Lcov # Gcov is a source code coverage analysis and statement-by-statement profiling tool. Gcov generates exact counts of the number of times each statement in a program is executed and annotates source code to add instrumentation. Gcov comes as a standard utility with the GNU Compiler Collection (GCC) suite.\nGcov是一个用来做代码覆盖率的测试工具，可以记录每一行代码的执行次数。\nLcov是一个可以将Gcov的数据转化为可以直观查看的HTML网页的工具。\n安装 # gcov应该已经随gcc安装，不需要单独安装。\nlcov 使用各自系统的命令安装。\n还有可能需要安装一下，genhtml。\n修改Makefile # 在需要包含进覆盖率测试的每一个单独的Makefile里，都加上以下这行：\nCFLAGS += -g -fprofile-arcs -ftest-coverage 在编译入口的那个Makefile里，添加类似以下的内容：\ngcov: $(LIB) gcc benchmark.c -g -o libzstd-gcov -I./lib -I./examples -O2 -fprofile-arcs -ftest-coverage ./lib/libzstd.a gcc benchmark.c -g -o libzstd-gcov.s -I./lib -I./examples -O2 -fprofile-arcs -ftest-coverage -S ./lib/libzstd.a 假设benchmark.c是此次测试的入口文件，libzstd是本次测试的库，主要是需要处理好依赖，虽然麻烦，但只要把报错里缺的都填上去就好了。\n指令序列 # make clean make -j$(nproc) make gcov gcov libzstd-gcov ./libzstd-gcov xxx lcov -c -d . -o libzstd-gcov.info genhtml -o gcov-$i libzstd-gcov.info tar -cvf gcov.tar gcov/ #这一步可选，只是打了个包 经过以上步骤，如果没有意外的话，就会生成一个gcov文件夹，在里面找到index.html打开，即可以看到美观的覆盖率结果，也可以点到每一个文件里去，看到每一行代码的执行次数。\n","date":"2024年12月23日","externalUrl":null,"permalink":"/posts/simple-gcov/","section":"Posts","summary":"","title":"简单的Gcov+Lcov使用","type":"posts"},{"content":"","date":"2024年12月23日","externalUrl":null,"permalink":"/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/","section":"Categories","summary":"","title":"开发工具","type":"categories"},{"content":" 流程 # 扩容虚拟硬盘 # 首先在虚拟机管理中，给虚拟磁盘扩容。此处省略。\n查看容量 # 启动虚拟机之后，可以查看容量：\nlsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS sda 8:0 0 100G 0 disk ├─sda1 8:1 0 1M 0 part ├─sda2 8:2 0 1G 0 part /boot └─sda3 8:3 0 39G 0 part ├─openeuler-root 253:0 0 35G 0 lvm / └─openeuler-swap 253:1 0 4G 0 lvm [SWAP] sr0 11:0 1 21.6G 0 rom 可以看到sda已经有了100G的大小，但是还没有应用到sda3上。\n查看分区表 # 运行如下命令，查看分区表。\n如果分区表类型为 GPT，直接操作即可。 如果是 MBR，扩展主分区可能有限制（建议转 GPT）。 sudo parted /dev/sda print 型号：ATA VMware Virtual I (scsi) 磁盘 /dev/sda：107GB 扇区大小 (逻辑/物理)：512B/512B 分区表：gpt 磁盘标志：pmbr_boot 编号 起始点 结束点 大小 文件系统 名称 标志 1 1049kB 2097kB 1049kB bios_grub 2 2097kB 1076MB 1074MB ext4 3 1076MB 42.9GB 41.9GB lvm 我这里是GPT，故直接下一步。\n扩容物理卷 # sudo parted /dev/sda GNU Parted 3.6 使用 /dev/sda 欢迎使用 GNU Parted！输入 \u0026#39;help\u0026#39; 来查看命令列表。 (parted) unit MiB (parted) print free 型号：ATA VMware Virtual I (scsi) 磁盘 /dev/sda：102400MiB 扇区大小 (逻辑/物理)：512B/512B 分区表：gpt 磁盘标志：pmbr_boot 编号 起始点 结束点 大小 文件系统 名称 标志 0.02MiB 1.00MiB 0.98MiB 可用空间 1 1.00MiB 2.00MiB 1.00MiB bios_grub 2 2.00MiB 1026MiB 1024MiB ext4 3 1026MiB 40959MiB 39933MiB lvm 40959MiB 102400MiB 61441MiB 可用空间 (parted) resizepart 3 100% (parted) quit 命令说明：\nunit MiB 更改大小显示单位 print free 显示包含剩余可用空间的信息 resizepart 3 100% 重置编号3即sda3的大小到能够得到100%，即把所有空余空间都分配给sda3。 更新内核分区信息，让系统识别新的分区大小：\nsudo partprobe /dev/sda\nlsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS sda 8:0 0 100G 0 disk ├─sda1 8:1 0 1M 0 part ├─sda2 8:2 0 1G 0 part /boot └─sda3 8:3 0 99G 0 part ├─openeuler-root 253:0 0 35G 0 lvm / └─openeuler-swap 253:1 0 4G 0 lvm [SWAP] sr0 11:0 1 21.6G 0 rom 可以看到这里，sda3的大小已经正确扩展了，但逻辑卷还是之前的大小。\n扩容逻辑卷 # sudo lvextend -l +100%FREE /dev/mapper/openeuler-root Device read short 16896 bytes remaining Size of logical volume openeuler/root changed from 35.04 GiB (8971 extents) to 95.04 GiB (24331 extents). Logical volume openeuler/root successfully resized. 这里的 +100%FREE 表示使用所有可用空间。\n而且需要注意，要保证命令中逻辑卷的名字需要和lsblk的结果中看到的一致。\nlsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS sda 8:0 0 100G 0 disk ├─sda1 8:1 0 1M 0 part ├─sda2 8:2 0 1G 0 part /boot └─sda3 8:3 0 99G 0 part ├─openeuler-root 253:0 0 95G 0 lvm / └─openeuler-swap 253:1 0 4G 0 lvm [SWAP] sr0 11:0 1 21.6G 0 rom 能看到，openeuler-root已经是扩容完成了。\n扩容文件系统 # 如果是ext4：\nsudo resize2fs /dev/mapper/openeuler-root 如果是xfs：\nsudo xfs_growfs / 成功后，检查结果：\ndf -h 文件系统 大小 已用 可用 已用% 挂载点 /dev/mapper/openeuler-root 94G 33G 57G 37% / devtmpfs 4.0M 0 4.0M 0% /dev tmpfs 3.7G 0 3.7G 0% /dev/shm tmpfs 4.0M 0 4.0M 0% /sys/fs/cgroup tmpfs 1.5G 8.8M 1.5G 1% /run tmpfs 3.7G 0 3.7G 0% /tmp /dev/sda2 974M 481M 426M 54% /boot 可以看到，文件系统里也显示为扩容后的容量了。\n","date":"2024年11月29日","externalUrl":null,"permalink":"/posts/resize-disk-in-cli/","section":"Posts","summary":"","title":"Linux虚拟机中命令行简单硬盘扩容","type":"posts"},{"content":"","date":"2024年11月29日","externalUrl":null,"permalink":"/tags/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/","section":"Tags","summary":"","title":"系统管理","type":"tags"},{"content":"","date":"2024年11月29日","externalUrl":null,"permalink":"/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/","section":"Tags","summary":"","title":"虚拟机","type":"tags"},{"content":"","date":"2024年11月29日","externalUrl":null,"permalink":"/tags/%E7%A1%AC%E7%9B%98%E6%89%A9%E5%AE%B9/","section":"Tags","summary":"","title":"硬盘扩容","type":"tags"},{"content":"","date":"2024年11月26日","externalUrl":null,"permalink":"/tags/github/","section":"Tags","summary":"","title":"GitHub","type":"tags"},{"content":" 流程概览 # 在本地唰唰写。 push 到你的 GitHub 仓库。 GitHub Actions 自动执行 deploy 动作。 部署成功访问 \u0026lt;username\u0026gt;.github.io 查看。 创建仓库 # 仓库名 # 在GitHub上创建一个名为\u0026lt;username\u0026gt;.github.io的仓库，比如我这个仓库就叫作：moxianhs.github.io，后面访问网页也是这个地址。\n你当然可以选择一个其他的名字，后面的流程也都能跑通，但唯一的问题就是：如果使用其他名字命名仓库，例如mox-blog，后面部署完成之后，访问地址就变成了moxianhs.github.io/mox-blog，如果不进行额外的配置，所有的 css、js、亦或是资源文件，都将找不到正确路径。\n主分支 # 注意主分支最好是main，主要的文件都放在这里，如果你选择用其他类似于master作为主分支，当然可以，注意在后面的 deploy 文件里改好对应字段。\n配置仓库 # Action 权限 # 进入你的仓库，在Settings -\u0026gt; Actions -\u0026gt; General -\u0026gt; Workflow permissions处，选择 Read and write permissions，否则，自动化动作无法将生成页面 push 进对应分支。\n部署 # 本地配置 # deploy.yaml # 在本地创建.github/workflows/deploy.yaml文件。\n内容大致如下：\nname: Deploy Hugo site to GitHub Pages on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v3 with: submodules: true - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build site run: hugo build - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 注意on.push.branches的值，这里必须设置成你的主分支的名字。\n禁用 jekyll # GitHub Pages 可能会默认以 Jekyll 的方式解析文件，即使项目是 Hugo 构建的。这样就会出现构建失败的问题。故需要在项目根目录生成一个static/.nojekyll的空文件以禁用 jekyll 解析。\n本地仓库设置 # 设置远端仓库为之前配置好的空的GitHub仓库。 远端上游分支设置为主分支，如main。 在本地事先测试好博客能正常运行。 git add 所有除了 public的文件。 git push 到远端上游即可。 远端配置 # Pages # Settings -\u0026gt; Pages 里在 Branch 处，记得检查是否已经选择好gh-pages作为发布分支。\n以能看到\nYour GitHub Pages site is currently being built from the gh-pages branch.` 这句话为准。\n事后 # 如果能在Settings -\u0026gt; Pages里看到类似:\nYour site is live at https://moxianhs.github.io/\n那就证明部署成功了，可以直接点击路径访问，旁边也有一个Visit site的按键，一键直达。\n如果失败，可以在仓库的Actions页面，看到部署的全过程，可以查看每一个步骤的日志，检查具体的失败信息，对症下药。\n","date":"2024年11月26日","externalUrl":null,"permalink":"/posts/github-pages-configuration/","section":"Posts","summary":"","title":"Github Pages Configuration","type":"posts"},{"content":"","date":"2024年11月26日","externalUrl":null,"permalink":"/tags/%E9%83%A8%E7%BD%B2/","section":"Tags","summary":"","title":"部署","type":"tags"},{"content":" Hugo 是什么 # Hugo是一个静态网页生成工具，可以通过配置好的主题和你自己写的 markdown 文档生成一个可以部署的静态网站。\n所以需要什么呢？\nhugo装到你的机器上。\ntheme 一个主题，可以去hugo的官网里去下载。\nHugo 安装 # 在安装Hugo之前，请首先自行安装go和git到你的系统上。\nWindows # 推荐直接下载二进制安装。官网推荐的使用包管理器的安装方式存在货不对版的问题。\nhttps://github.com/gohugoio/hugo/releases\nmacOS # brew install hugo\nLinux # ArchLinux # sudo pacman -S hugo\nUbuntu/Debian # sudo apt install hugo\nFedora # sudo dnf install hugo\nOthers # 亦有prebuilt可供下载。\n验证安装成功 # hugo version 输出依据版本平台等有所不同，示例如下：\nhugo v0.136.5+extended darwin/arm64 BuildDate=2024-10-24T12:26:27Z VendorInfo=brew Blowfish 安装 # 这是一个主题，如果这个主题因为系统环境安装不上，可以换成其他主题（说的就是你啊，Windows）。\nCLI # npx blowfish-tools\nor\nnpm i -g blowfish-tools\n而后：\nblowfish-tools\nNon-CLI # cd mywebsite git init git submodule add -b main https://github.com/nunocoracao/blowfish.git themes/blowfish 在项目根目录，删除由 Hugo 自动生成的 hugo.toml，从 themes/blowfish/config/_default 里复制 hugo.toml 到根目录。\n开始使用 Hugo # 开一个新博客：\nhugo new site \u0026lt;site-name\u0026gt;\n写一篇新文章：\nhugo new posts/\u0026lt;article-name\u0026gt;.md\n启动：\nhugo server\n启动（带草稿）：\nhugo server -D\n更多请见：Basic usage\n","date":"2024年11月26日","externalUrl":null,"permalink":"/posts/hugo-configuration/","section":"Posts","summary":"","title":"Hugo Configuration","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]