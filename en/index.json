


[{"content":"","date":"23 October 2025","externalUrl":null,"permalink":"/en/","section":"Mox's Blog","summary":"","title":"Mox's Blog","type":"page"},{"content":"","date":"23 October 2025","externalUrl":null,"permalink":"/en/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" 配置 # 我是使用 Doom Emacs 的配置，所以在添加 ox-hugo 支持方面比较简单。\n(doom! ;; 其他配置 :lang (org +pretty +hugo) ) 在你的博客目录下，开一个用来放 org 的目录，比如根目录下：\n~/W/Blog/mox-blog [main] λ tree -L 1 . ├── archetypes ├── assets ├── config ├── content ├── data ├── hugo.toml ├── i18n ├── layouts ├── org ├── public ├── resources ├── static └── themes 13 directories, 1 file 在 org 目录下就可以用 org-mode 写博客了。\n确定好目录位置后，需要在博客的头部元数据里指定 hugo 工程的目录，也就是当前博客的根目录：\n#+title: 如何在 Hugo 里写 Org #+author: Mox W #+date: \u0026lt;2025-10-11 六\u0026gt; #+hugo_base_dir: ../ 生成 Markdown # 直接使用 org 写就的文章，需要转换成 Markdown 才能被 Hugo 识别。\n在 Emacs 里，我们直接祭出 M-x 大法： M-x org-export-dispatch\n然后在弹出的菜单里敲击 H h 即可。\n这里注意一定是生成 Hugo Capatible Markdown ，选择 File to Md file 。\n其他选项里可能有 subtree to md file ，这相当于只将某一个标题（子树）导出。\n只要配置好 hugo_base_dir ，导出的 md 文件应该就会正常地落到 content/posts/ 里。\n试一试吧。\n","date":"2025年10月11日","externalUrl":null,"permalink":"/posts/write-org-in-hugo/","section":"Posts","summary":"","title":"如何在 Hugo 里写 Org","type":"posts"},{"content":" 安装 # 如正常安装 openEuler 一样安装。\n换源 # 先找到设备号\nlsblk # 在结果里找到 TYPE 为 rom 的设备，看看大小对不对 假设是 /dev/sr0 （大概率是这个）\n挂载：\nmkdir -p /mnt/everything mount /dev/sr0 /mnt/everything 换源：\n# 备份一下 mv /etc/yum.repo.d/openEuler.repo /etc/yum.repo.d/openEuler.repo.backup vi /etc/yum.repo.d/openEuler.repo 将文件内容改为以下：\n[openEuler] name=openEuler baseurl=file:///mnt/everything enable=1 gpgcheck=0 以上文件名需要随机应变，根据现场环境更改。\n测试一下：\nyum clean all yum makecache yum install vim 不出意外应该就能装了。\n","date":"2025年10月9日","externalUrl":null,"permalink":"/posts/euler-everything/","section":"Posts","summary":"","title":"离线环境下使用 everthing 版本 ISO 安装 openEuler 系统并换源","type":"posts"},{"content":" 关于我 一个始终在徒劳的人。\n希望讲故事给世界听。\n在一个玖捌伍给电脑的内存打补丁。\n博客的设计上，借鉴了 昼梦日和 ，非常好审美使我大脑旋转。\n评论系统参考了这个博客 和 昼梦日和。\n","date":"2025年10月8日","externalUrl":null,"permalink":"/about/","section":"默","summary":"","title":"About","type":"page"},{"content":" 概览 # 通过使用 Cherry Studio ，你可以调用各种各样的大语言模型（Large Language Model）来完成你需要 AI 回答你的任何问题。\n这些大模型都是各个厂商通过应用程序接口（Application Programming Interface, API）的形式提供。\n你可以选择使用 OpenAI 提供的 ChatGPT 或者 Anthropic 提供的 Claude 等等，但服务受限，喜欢封号，价格昂贵是不得不考虑的问题。\n你也可以选择使用开源模型服务平台，这里会用云平台提供大量的已经部署好的开源模型，可以直接调用，且价格低廉。\n你经历过使用官方的 DeepSeek ，不断重复服务忙服务暂时不可用的事情吗？你有经历过使用腾讯元宝或者其他第三方部署的 DeepSeek ，发现参数量不透明性能不好不能及时更新版本吗？\n使用硅基流动（SiliconFlow）这种平台就能解决这些问题。\n硅基流动 # 首先在硅基流动的 官网 里，像其他网站一样注册一个账号。\n通过我的邀请链接注册，你和我都会获得 14 元的赠送余额，所以，拜托了：注册链接\n登录后，就会进入到模型广场的界面：\n在这里就可以知道当前有哪些模型可以供你调用。\n需要注意的是，硅基流动的费用体系，分为「赠送余额」和「充值余额」：\n部分模型例如 Pro 开头的模型，都是只能使用充值余额的，但不带 Pro 前缀的模型，基本上都是可以使用赠送余额的。\n「💰」图标表示的就是支持使用充值余额。 「🎁」图表表示的就是支持使用赠送余额。 赠送余额是注册时赠送的，完成校园认证也会给一些。\n点击一个模型，就会弹出其详情页面，会展示其类型、参数量、价格等一系列信息。点击模型名后面的复制图标，可快捷复制模型名，以供调用时使用：\n点击在线体验，可以直接跳转到试用界面，直接尝试对应的模型，此处的使用方式就和其他服务（ChatGPT, DeepSeek） 没什么太大的区别了：\n挑选好心仪的模型（不知道怎么选，就选最新的）后，就可以进入到下一节了。\nCherry Studio # Cherry Studio 直译就是樱桃工作室，可以在本地调用各种服务商提供的大模型服务，且所有数据都存在本地，故软件本身不会引入任何隐私风险。\n打开 Cherry Studio 的 官网 ，点击下载客户端即可：\n对于一般 Windows 系统，下载 Windows 标准版即可。\n下载安装完成之后，打开 Cherry Studio ，就能得到类似以下界面：\n点击左下角的齿轮设置图标，进入设置界面，需要配置硅基流动的 API 密钥才能愉快使用之前在硅基流动那边选好的模型。\n回到硅基流动这边，点击侧边栏的钥匙按钮，进入密钥管理的界面：\n点击「新建 API 密钥」，输入密钥描述即可点击「新建密钥」：\n复制新的密钥：\n回到 Cherry Studio 这里，在设置里输出硅基流动的 API Key：\n点击右侧的检测按钮，在弹出页面里，随意选择一个内置的模型，点击确定，弹出「连接成功」或者密钥右侧的检测按钮变成绿色的对钩，就可以了。\n还记得之间可以复制模型名吗？现在到时候了。\n复制好需要的模型名，在 Cherry Studio 的硅基流动设置页面里，滚动到最下面，有个添加模型，把你复制的模型名贴进去就好啦。\n添加好，就可以回到最开始 Cherry Studio 的页面，开始一轮对话啦。\n在对话页面，点击话题，就可以看到过往的聊天记录和新增话题的按钮。\n其中，顶部的模型名点击之后可以切换模型，如果没有你想要的则去设置里添加：\n现在，一个可以使用的 Cherry Studio 就展现在你面前，在输入框里提一个问题，然后按下回车吧。\n课后习题 # Cherry Studio 还有很多很多按钮我没有介绍是什么，但此时已经有一个可以使用的提问系统了，所以你应该怎么做，就不用我多说了吧？\n不知道？去问 AI 啊。\n","date":"2025年10月8日","externalUrl":null,"permalink":"/posts/cherry-studio-and-siliconflow/","section":"Posts","summary":"","title":"给完全陌生者的 Cherry Studio 和 SiliconFlow 入门指南","type":"posts"},{"content":"如下图所示，是本文希望达到的效果。\n![Logo](/img/miHoYo-Logo.png) 将图片文件放到static下面，编译后会自动引入。\nls static/img/ miHoYo-Logo.png ","date":"2025年1月2日","externalUrl":null,"permalink":"/posts/imgs-beside-article/","section":"Posts","summary":"","title":"静态博客文章里的图片","type":"posts"},{"content":" Gcov + Lcov # Gcov is a source code coverage analysis and statement-by-statement profiling tool. Gcov generates exact counts of the number of times each statement in a program is executed and annotates source code to add instrumentation. Gcov comes as a standard utility with the GNU Compiler Collection (GCC) suite.\nGcov是一个用来做代码覆盖率的测试工具，可以记录每一行代码的执行次数。\nLcov是一个可以将Gcov的数据转化为可以直观查看的HTML网页的工具。\n安装 # gcov应该已经随gcc安装，不需要单独安装。\nlcov 使用各自系统的命令安装。\n还有可能需要安装一下，genhtml。\n修改Makefile # 在需要包含进覆盖率测试的每一个单独的Makefile里，都加上以下这行：\nCFLAGS += -g -fprofile-arcs -ftest-coverage 在编译入口的那个Makefile里，添加类似以下的内容：\ngcov: $(LIB) gcc benchmark.c -g -o libzstd-gcov -I./lib -I./examples -O2 -fprofile-arcs -ftest-coverage ./lib/libzstd.a gcc benchmark.c -g -o libzstd-gcov.s -I./lib -I./examples -O2 -fprofile-arcs -ftest-coverage -S ./lib/libzstd.a 假设benchmark.c是此次测试的入口文件，libzstd是本次测试的库，主要是需要处理好依赖，虽然麻烦，但只要把报错里缺的都填上去就好了。\n指令序列 # make clean make -j$(nproc) make gcov gcov libzstd-gcov ./libzstd-gcov xxx lcov -c -d . -o libzstd-gcov.info genhtml -o gcov-$i libzstd-gcov.info tar -cvf gcov.tar gcov/ #这一步可选，只是打了个包 经过以上步骤，如果没有意外的话，就会生成一个gcov文件夹，在里面找到index.html打开，即可以看到美观的覆盖率结果，也可以点到每一个文件里去，看到每一行代码的执行次数。\n","date":"2024年12月23日","externalUrl":null,"permalink":"/posts/simple-gcov/","section":"Posts","summary":"","title":"简单的Gcov+Lcov使用","type":"posts"},{"content":" 流程 # 扩容虚拟硬盘 # 首先在虚拟机管理中，给虚拟磁盘扩容。此处省略。\n查看容量 # 启动虚拟机之后，可以查看容量：\nlsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS sda 8:0 0 100G 0 disk ├─sda1 8:1 0 1M 0 part ├─sda2 8:2 0 1G 0 part /boot └─sda3 8:3 0 39G 0 part ├─openeuler-root 253:0 0 35G 0 lvm / └─openeuler-swap 253:1 0 4G 0 lvm [SWAP] sr0 11:0 1 21.6G 0 rom 可以看到sda已经有了100G的大小，但是还没有应用到sda3上。\n查看分区表 # 运行如下命令，查看分区表。\n如果分区表类型为 GPT，直接操作即可。 如果是 MBR，扩展主分区可能有限制（建议转 GPT）。 sudo parted /dev/sda print 型号：ATA VMware Virtual I (scsi) 磁盘 /dev/sda：107GB 扇区大小 (逻辑/物理)：512B/512B 分区表：gpt 磁盘标志：pmbr_boot 编号 起始点 结束点 大小 文件系统 名称 标志 1 1049kB 2097kB 1049kB bios_grub 2 2097kB 1076MB 1074MB ext4 3 1076MB 42.9GB 41.9GB lvm 我这里是GPT，故直接下一步。\n扩容物理卷 # sudo parted /dev/sda GNU Parted 3.6 使用 /dev/sda 欢迎使用 GNU Parted！输入 \u0026#39;help\u0026#39; 来查看命令列表。 (parted) unit MiB (parted) print free 型号：ATA VMware Virtual I (scsi) 磁盘 /dev/sda：102400MiB 扇区大小 (逻辑/物理)：512B/512B 分区表：gpt 磁盘标志：pmbr_boot 编号 起始点 结束点 大小 文件系统 名称 标志 0.02MiB 1.00MiB 0.98MiB 可用空间 1 1.00MiB 2.00MiB 1.00MiB bios_grub 2 2.00MiB 1026MiB 1024MiB ext4 3 1026MiB 40959MiB 39933MiB lvm 40959MiB 102400MiB 61441MiB 可用空间 (parted) resizepart 3 100% (parted) quit 命令说明：\nunit MiB 更改大小显示单位 print free 显示包含剩余可用空间的信息 resizepart 3 100% 重置编号3即sda3的大小到能够得到100%，即把所有空余空间都分配给sda3。 更新内核分区信息，让系统识别新的分区大小：\nsudo partprobe /dev/sda\nlsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS sda 8:0 0 100G 0 disk ├─sda1 8:1 0 1M 0 part ├─sda2 8:2 0 1G 0 part /boot └─sda3 8:3 0 99G 0 part ├─openeuler-root 253:0 0 35G 0 lvm / └─openeuler-swap 253:1 0 4G 0 lvm [SWAP] sr0 11:0 1 21.6G 0 rom 可以看到这里，sda3的大小已经正确扩展了，但逻辑卷还是之前的大小。\n扩容逻辑卷 # sudo lvextend -l +100%FREE /dev/mapper/openeuler-root Device read short 16896 bytes remaining Size of logical volume openeuler/root changed from 35.04 GiB (8971 extents) to 95.04 GiB (24331 extents). Logical volume openeuler/root successfully resized. 这里的 +100%FREE 表示使用所有可用空间。\n而且需要注意，要保证命令中逻辑卷的名字需要和lsblk的结果中看到的一致。\nlsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS sda 8:0 0 100G 0 disk ├─sda1 8:1 0 1M 0 part ├─sda2 8:2 0 1G 0 part /boot └─sda3 8:3 0 99G 0 part ├─openeuler-root 253:0 0 95G 0 lvm / └─openeuler-swap 253:1 0 4G 0 lvm [SWAP] sr0 11:0 1 21.6G 0 rom 能看到，openeuler-root已经是扩容完成了。\n扩容文件系统 # 如果是ext4：\nsudo resize2fs /dev/mapper/openeuler-root 如果是xfs：\nsudo xfs_growfs / 成功后，检查结果：\ndf -h 文件系统 大小 已用 可用 已用% 挂载点 /dev/mapper/openeuler-root 94G 33G 57G 37% / devtmpfs 4.0M 0 4.0M 0% /dev tmpfs 3.7G 0 3.7G 0% /dev/shm tmpfs 4.0M 0 4.0M 0% /sys/fs/cgroup tmpfs 1.5G 8.8M 1.5G 1% /run tmpfs 3.7G 0 3.7G 0% /tmp /dev/sda2 974M 481M 426M 54% /boot 可以看到，文件系统里也显示为扩容后的容量了。\n","date":"2024年11月29日","externalUrl":null,"permalink":"/posts/resize-disk-in-cli/","section":"Posts","summary":"","title":"Linux虚拟机中命令行简单硬盘扩容","type":"posts"},{"content":" 流程概览 # 在本地唰唰写。 push 到你的 GitHub 仓库。 GitHub Actions 自动执行 deploy 动作。 部署成功访问 \u0026lt;username\u0026gt;.github.io 查看。 创建仓库 # 仓库名 # 在GitHub上创建一个名为\u0026lt;username\u0026gt;.github.io的仓库，比如我这个仓库就叫作：moxianhs.github.io，后面访问网页也是这个地址。\n你当然可以选择一个其他的名字，后面的流程也都能跑通，但唯一的问题就是：如果使用其他名字命名仓库，例如mox-blog，后面部署完成之后，访问地址就变成了moxianhs.github.io/mox-blog，如果不进行额外的配置，所有的 css、js、亦或是资源文件，都将找不到正确路径。\n主分支 # 注意主分支最好是main，主要的文件都放在这里，如果你选择用其他类似于master作为主分支，当然可以，注意在后面的 deploy 文件里改好对应字段。\n配置仓库 # Action 权限 # 进入你的仓库，在Settings -\u0026gt; Actions -\u0026gt; General -\u0026gt; Workflow permissions处，选择 Read and write permissions，否则，自动化动作无法将生成页面 push 进对应分支。\n部署 # 本地配置 # deploy.yaml # 在本地创建.github/workflows/deploy.yaml文件。\n内容大致如下：\nname: Deploy Hugo site to GitHub Pages on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v3 with: submodules: true - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build site run: hugo build - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 注意on.push.branches的值，这里必须设置成你的主分支的名字。\n禁用 jekyll # GitHub Pages 可能会默认以 Jekyll 的方式解析文件，即使项目是 Hugo 构建的。这样就会出现构建失败的问题。故需要在项目根目录生成一个static/.nojekyll的空文件以禁用 jekyll 解析。\n本地仓库设置 # 设置远端仓库为之前配置好的空的GitHub仓库。 远端上游分支设置为主分支，如main。 在本地事先测试好博客能正常运行。 git add 所有除了 public的文件。 git push 到远端上游即可。 远端配置 # Pages # Settings -\u0026gt; Pages 里在 Branch 处，记得检查是否已经选择好gh-pages作为发布分支。\n以能看到\nYour GitHub Pages site is currently being built from the gh-pages branch.` 这句话为准。\n事后 # 如果能在Settings -\u0026gt; Pages里看到类似:\nYour site is live at https://moxianhs.github.io/\n那就证明部署成功了，可以直接点击路径访问，旁边也有一个Visit site的按键，一键直达。\n如果失败，可以在仓库的Actions页面，看到部署的全过程，可以查看每一个步骤的日志，检查具体的失败信息，对症下药。\n","date":"2024年11月26日","externalUrl":null,"permalink":"/posts/github-pages-configuration/","section":"Posts","summary":"","title":"Github Pages Configuration","type":"posts"},{"content":" Hugo 是什么 # Hugo是一个静态网页生成工具，可以通过配置好的主题和你自己写的 markdown 文档生成一个可以部署的静态网站。\n所以需要什么呢？\nhugo装到你的机器上。\ntheme 一个主题，可以去hugo的官网里去下载。\nHugo 安装 # 在安装Hugo之前，请首先自行安装go和git到你的系统上。\nWindows # 推荐直接下载二进制安装。官网推荐的使用包管理器的安装方式存在货不对版的问题。\nhttps://github.com/gohugoio/hugo/releases\nmacOS # brew install hugo\nLinux # ArchLinux # sudo pacman -S hugo\nUbuntu/Debian # sudo apt install hugo\nFedora # sudo dnf install hugo\nOthers # 亦有prebuilt可供下载。\n验证安装成功 # hugo version 输出依据版本平台等有所不同，示例如下：\nhugo v0.136.5+extended darwin/arm64 BuildDate=2024-10-24T12:26:27Z VendorInfo=brew Blowfish 安装 # 这是一个主题，如果这个主题因为系统环境安装不上，可以换成其他主题（说的就是你啊，Windows）。\nCLI # npx blowfish-tools\nor\nnpm i -g blowfish-tools\n而后：\nblowfish-tools\nNon-CLI # cd mywebsite git init git submodule add -b main https://github.com/nunocoracao/blowfish.git themes/blowfish 在项目根目录，删除由 Hugo 自动生成的 hugo.toml，从 themes/blowfish/config/_default 里复制 hugo.toml 到根目录。\n开始使用 Hugo # 开一个新博客：\nhugo new site \u0026lt;site-name\u0026gt;\n写一篇新文章：\nhugo new posts/\u0026lt;article-name\u0026gt;.md\n启动：\nhugo server\n启动（带草稿）：\nhugo server -D\n更多请见：Basic usage\n","date":"2024年11月26日","externalUrl":null,"permalink":"/posts/hugo-configuration/","section":"Posts","summary":"","title":"Hugo Configuration","type":"posts"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]